const b=(t,e,r,o,c)=>{var u;if(!(o<0||o>=e||c<0||c>=r))return(u=t[c])==null?void 0:u[o]};function W(t,e,r,o,c,u){const{speed:C}=t;let s=t.x,a=t.y;t.lastPositions=t.lastPositions||[],t.lastPositions.push({x:s,y:a}),t.lastPositions.length>4&&t.lastPositions.shift();let l=t.dx,i=t.dy,y=!1,h=!1;const n=(f,E)=>f<0||f>=r||E<0||E>=o||b(e,r,o,f,E)===d.CAPTURED;let A=s,g=a;for(let f=0;f<Math.abs(C);++f){let E=A,p=g,R=E+Math.sign(l),P=p+Math.sign(i),v=n(R,p),w=n(E,P);if(n(R,P)&&!v&&!w){l*=-1,i*=-1,y=!0;break}else v&&(l*=-1,y=!0,R=E),w&&(i*=-1,y=!0,P=p);if(c&&u.some(I=>I.x===R&&I.y===P)){console.log(`Bouncer hit trail at ${R}, ${P}!`),h=!0;break}if(A=R,g=P,y)break}if(t.dx=l,t.dy=i,h||(t.x=A,t.y=g),t.lastPositions.length>=4){const f=t.lastPositions[0];t.x===f.x&&t.y===f.y?t.stuckCounter=(t.stuckCounter||0)+1:t.stuckCounter=0,t.stuckCounter>=10&&(console.log(`Bouncer seems stuck at ${t.x},${t.y}. Reversing.`),t.dx*=-1,t.dy*=-1,t.stuckCounter=0,t.lastPositions=[])}if(b(e,r,o,t.x,t.y)===d.CAPTURED){console.warn(`Bouncer ended on captured tile at ${t.x},${t.y}. Moving back.`);const f=t.lastPositions[t.lastPositions.length-2];f&&b(e,r,o,f.x,f.y)!==d.CAPTURED?(t.x=f.x,t.y=f.y):(t.dx*=-1,t.dy*=-1,console.error(`Bouncer fallback failed at ${t.x},${t.y}`))}return h}function J(t,e,r,o,c,u){const{speed:C}=t;let{dx:s,dy:a,x:l,y:i}=t;if(t.lastPositions=t.lastPositions||[],t.lastPositions.push({x:l,y:i}),t.lastPositions.length>4&&t.lastPositions.shift(),t.lastPositions.length>=4){const P=t.lastPositions[0];l===P.x&&i===P.y?t.stuckCounter=(t.stuckCounter||0)+1:t.stuckCounter=0,t.stuckCounter>=10&&(console.log(`Patroller stuck at ${l},${i}. Reversing direction.`),s*=-1,a*=-1,s===0&&a===0&&C!==0&&(s=C),t.stuckCounter=0,t.lastPositions=[])}const y=l+s,h=i+a;if(c&&u.some(P=>P.x===y&&P.y===h))return console.log(`Patroller hit trail at ${y}, ${h}!`),!0;b(e,r,o,y,h);const n=b(e,r,o,l+s,i),A=b(e,r,o,l,i+a);let g=!1,f=!1;n!==d.CAPTURED&&(g=!0),A!==d.CAPTURED&&(f=!0),g&&(s*=-1),f&&(a*=-1),t.dx=s,t.dy=a;const E=l+s,p=i+a,R=b(e,r,o,E,p);if(R===d.CAPTURED)t.x=E,t.y=p;else if(console.log(`Patroller move blocked at (${l},${i}) to (${E},${p}). State: ${R}`),t.stuckCounter>10/2){const v=[{dx:C,dy:0},{dx:-C,dy:0},{dx:0,dy:C},{dx:0,dy:-C}].filter(w=>{const V=l+w.dx,I=i+w.dy;return b(e,r,o,V,I)===d.CAPTURED});if(v.length>0){const w=v[Math.floor(Math.random()*v.length)];t.dx=w.dx,t.dy=w.dy,console.log(`Patroller changing direction to (${t.dx}, ${t.dy})`)}}if(b(e,r,o,t.x,t.y)!==d.CAPTURED){console.warn(`Patroller ended on off-path tile at ${t.x},${t.y}. Moving back.`);const P=t.lastPositions[t.lastPositions.length-2];P&&b(e,r,o,P.x,P.y)===d.CAPTURED?(t.x=P.x,t.y=P.y):(console.error(`Patroller off-path fallback failed at ${t.x},${t.y}`),t.x=1,t.y=1,t.dx=C,t.dy=0)}return!1}function j(t){const{level:e,gridCols:r,gridRows:o,grid:c,player:u,baseEnemyCount:C,basePatrollerCount:s,enemySpeed:a}=t;let l=[];const i=C+Math.floor(e/2),y=s+Math.floor(e/3),h=Math.max(1,i-y),n=Math.max(1,a+Math.floor((e-1)/4));for(let A=0;A<y;A++){let g,f,E,p;switch(A%4){case 0:g=2,f=1,E=n,p=n;break;case 1:g=r-2,f=2,E=-n,p=n;break;case 2:g=r-3,f=o-2,E=-n,p=-n;break;default:g=1,f=o-3,E=n,p=-n;break}E===0&&p===0&&n!==0&&(E=n,p=n),l.push({type:"patroller",x:g,y:f,dx:E,dy:p,speed:n,lastPositions:[],stuckCounter:0})}for(let A=0;A<h;A++){let g,f,E=0;do if(g=Math.floor(Math.random()*(r-4))+2,f=Math.floor(Math.random()*(o-4))+2,E++,E>100)break;while(b(c,r,o,g,f)!==d.UNCAPTURED||l.some(v=>v.x===g&&v.y===f)||u&&g===u.x&&f===u.y);const p=Math.floor(Math.random()*4);let R=0,P=0;p===0?(R=n,P=n):p===1?(R=-n,P=n):p===2?(R=-n,P=-n):(R=n,P=-n),l.push({type:"bouncer",x:g,y:f,dx:R,dy:P,speed:n,lastPositions:[],stuckCounter:0})}return l}function Z(t){const{enemies:e,grid:r,player:o,isDrawing:c,currentTrail:u,gridCols:C,gridRows:s}=t;let a=!1;for(const l of e){if(o&&l.x===o.x&&l.y===o.y){if(l.type==="patroller"){console.log(`Patroller started turn on player at (${o.x}, ${o.y})!`),a=!0;break}else if(l.type==="bouncer"&&c){console.log(`Bouncer started turn on player at (${o.x}, ${o.y}) while drawing!`),a=!0;break}}let i=!1;if(l.type==="bouncer"?i=W(l,r,C,s,c,u):l.type==="patroller"&&(i=J(l,r,C,s,c,u)),i){a=!0;break}if(o&&l.x===o.x&&l.y===o.y){if(l.type==="patroller"){console.log(`Patroller moved into player at (${o.x}, ${o.y})!`),a=!0;break}else if(l.type==="bouncer"&&c){console.log(`Bouncer moved into player at (${o.x}, ${o.y}) while drawing!`),a=!0;break}}}return{lifeLost:a}}const $=64,k=48,F={x:$/2,y:k-2},d={UNCAPTURED:0,CAPTURED:1,TRAIL:2};let U=0,_=3,M=1,G=0,x={...F,dx:0,dy:0},T=[],S=[],L=!1,N=[],D=!1,z=!1,O=!0,Y=0;const q=75,m=1e3,H=1e4;function Q(){T=Array(k).fill(null).map(()=>Array($).fill(d.UNCAPTURED));for(let t=0;t<k;t++)for(let e=0;e<$;e++)(e<=1||e>=$-2||t<=1||t>=k-2)&&(T[t][e]=d.CAPTURED)}function K(){x.x=F.x,x.y=F.y,x.dx=0,x.dy=0}function X(){_--,L=!1,S.forEach(t=>{var e;((e=T[t.y])==null?void 0:e[t.x])===d.TRAIL&&(T[t.y][t.x]=d.UNCAPTURED)}),S=[],K(),_<=0&&(D=!0,O=!1)}function nt(t){if(!(!O||D))switch(t){case"ArrowUp":x.dx=0,x.dy=-1;break;case"ArrowDown":x.dx=0,x.dy=1;break;case"ArrowLeft":x.dx=-1,x.dy=0;break;case"ArrowRight":x.dx=1,x.dy=0;break}}function tt(t,e,r,o){var a;const c=[{x:t,y:e}],u=new Set;u.add(`${t},${e}`);let C=0,s=!1;for(;c.length>0;){const{x:l,y:i}=c.shift();o.some(h=>h.x===l&&h.y===i)&&(s=!0),C++;const y=[{x:l+1,y:i},{x:l-1,y:i},{x:l,y:i+1},{x:l,y:i-1}];for(const h of y){const n=`${h.x},${h.y}`;h.x>=0&&h.x<$&&h.y>=0&&h.y<k&&!u.has(n)&&((a=r[h.y])==null?void 0:a[h.x])===d.UNCAPTURED&&(u.add(n),c.push(h))}}return{count:C,containsEnemy:s,visited:u}}function et(t){var C;if(!t||t.length===0)return 0;const e=T.map(s=>[...s]);t.forEach(s=>{var a;((a=e[s.y])==null?void 0:a[s.x])!==void 0&&(e[s.y][s.x]=d.CAPTURED)});const r=[],o=new Set;for(const s of t){const a=[{x:s.x+1,y:s.y},{x:s.x-1,y:s.y},{x:s.x,y:s.y+1},{x:s.x,y:s.y-1}];for(const l of a){const i=`${l.x},${l.y}`;if(l.x>=0&&l.x<$&&l.y>=0&&l.y<k&&!o.has(i)&&((C=e[l.y])==null?void 0:C[l.x])===d.UNCAPTURED){o.add(i);const y=tt(l.x,l.y,e,N);y.visited.forEach(h=>{var g;const[n,A]=h.split(",").map(Number);((g=e[A])==null?void 0:g[n])===d.UNCAPTURED&&(e[A][n]=99)}),r.push(y)}}}if(r.length===0)return console.log("No uncaptured areas found adjacent to trail."),0;const c=r.filter(s=>!s.containsEnemy);if(c.length===0&&r.some(s=>s.containsEnemy))return console.log("Flood fill areas contained enemies, capturing nothing."),0;if(c.length===0)return console.log("No areas to capture found."),0;let u=0;return c.forEach(s=>{s.visited.forEach(a=>{var y;const[l,i]=a.split(",").map(Number);((y=T[i])==null?void 0:y[l])===d.UNCAPTURED&&(T[i][l]=d.CAPTURED,u++)})}),t.forEach(s=>{var a;((a=T[s.y])==null?void 0:a[s.x])===d.TRAIL&&(T[s.y][s.x]=d.CAPTURED)}),u}function B(){let t=0,e=0;for(let r=0;r<k;r++)for(let o=0;o<$;o++)o<=1||o>=$-2||r<=1||r>=k-2||(e++,T[r][o]===d.CAPTURED&&t++);return e>0?t/e*100:0}function ot(){Z({enemies:N,grid:T,player:x,isDrawing:L,currentTrail:S,gridCols:$,gridRows:k}).lifeLost&&X()}const lt=(t,e)=>{var r;if(!(t<0||t>=$||e<0||e>=k))return(r=T[e])==null?void 0:r[t]};function st(){console.log(`Level ${M} Complete! Score: ${U}`),U+=m*M,z=!0,O=!1}function rt(){console.log(`Starting Level ${M+1}`),L=!1,S=[],z=!1,D=!1,M++,Q(),K(),N=j({level:M,gridCols:$,gridRows:k,grid:T,player:x,baseEnemyCount:2,basePatrollerCount:1,enemySpeed:1}),G=B(),Y=Math.floor(U/H)*H,O=!0}function at(){z&&rt()}function it(){return D}function ct(){if(!(!O||D)){if(x.dx!==0||x.dy!==0){const t=x.x+x.dx,e=x.y+x.dy;if(t>=0&&t<$&&e>=0&&e<k){const r=N.find(c=>c.x===t&&c.y===e);if(r)if(r.type==="patroller"){console.log(`Player moved into patroller at (${t}, ${e})!`),X();return}else if(L){console.log(`Player moved into bouncer at (${t}, ${e}) while drawing!`),X();return}else{console.log(`Player bumped into bouncer at (${t}, ${e}) while safe.`);return}const o=lt(t,e);if(o===d.CAPTURED){if(L){console.log("Trail complete!"),L=!1,S.push({x:t,y:e});const c=et(S);if(c>0){if(U+=c*10,console.log(`Captured ${c} cells. Score: ${U}`),U>=Y+H){let u=0;for(;U>=Y+H;)_++,u++,Y+=H;console.log(`Extra life(s) awarded: ${u}! Score: ${U}, Lives: ${_}`)}}else S.forEach(u=>{var C;((C=T[u.y])==null?void 0:C[u.x])===d.TRAIL&&(T[u.y][u.x]=d.CAPTURED)});if(S=[],G=B(),G>=q){st();return}}x.x=t,x.y=e}else if(o===d.UNCAPTURED)L||(L=!0,S=[]),S.push({x:t,y:e}),T[e][t]=d.TRAIL,x.x=t,x.y=e;else if(o===d.TRAIL){console.log("Player hit own trail!"),X();return}}}D||ot(),D||(G=B(),_<=0&&(D=!0,O=!1,console.log("Game Over triggered.")))}}function ft(t=1,e={}){console.log("Initializing game logic...");const{baseEnemyCount:r=2,basePatrollerCount:o=1,enemySpeed:c=1}=e;U=0,_=3,M=t,G=0,L=!1,S=[],N=[],D=!1,O=!0,Y=0,Q(),K(),N=j({level:t,gridCols:$,gridRows:k,grid:T,player:x,baseEnemyCount:r,basePatrollerCount:o,enemySpeed:c}),G=B(),console.log(`Game logic initialized. ${N.length} enemies spawned.`)}function ut(){return{score:U,lives:_,level:M,capturedPercentage:G,player:{...x},grid:T.map(t=>[...t]),enemies:N.map(t=>({...t})),isDrawing:L,currentTrail:S.map(t=>({...t})),gameOver:D,levelComplete:z,gameRunning:O,gridCols:$,gridRows:k,targetPercentage:q}}export{d as CellState,$ as GRID_COLS,k as GRID_ROWS,it as checkGameOver,ut as getGameState,nt as handlePlayerInput,ft as initGame,at as triggerNextLevelStart,ct as updateGame};
